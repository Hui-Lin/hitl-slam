/* Auto-generated by genmsg_cpp for file /home/samer/code_release/hitl-slam/vector_slam_msgs/msg/CobotLocalizationMsg.msg */
#ifndef VECTOR_SLAM_MSGS_MESSAGE_COBOTLOCALIZATIONMSG_H
#define VECTOR_SLAM_MSGS_MESSAGE_COBOTLOCALIZATIONMSG_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"


namespace vector_slam_msgs
{
template <class ContainerAllocator>
struct CobotLocalizationMsg_ {
  typedef CobotLocalizationMsg_<ContainerAllocator> Type;

  CobotLocalizationMsg_()
  : timeStamp(0.0)
  , x(0.0)
  , y(0.0)
  , angle(0.0)
  , angleUncertainty(0.0)
  , locationUncertainty(0.0)
  , map()
  , lastLaserRunTime(0.0)
  , laserRunTime(0.0)
  , laserNumObservedPoints(0)
  , laserNumCorrespondences(0)
  , laserStage0Weights(0.0)
  , laserStageRWeights(0.0)
  , laserMeanSqError(0.0)
  , lastPointCloudRunTime(0.0)
  , pointCloudRunTime(0.0)
  , pointCloudNumObservedPoints(0)
  , pointCloudNumCorrespondences(0)
  , pointCloudStage0Weights(0.0)
  , pointCloudStageRWeights(0.0)
  , pointCloudMeanSqError(0.0)
  {
  }

  CobotLocalizationMsg_(const ContainerAllocator& _alloc)
  : timeStamp(0.0)
  , x(0.0)
  , y(0.0)
  , angle(0.0)
  , angleUncertainty(0.0)
  , locationUncertainty(0.0)
  , map(_alloc)
  , lastLaserRunTime(0.0)
  , laserRunTime(0.0)
  , laserNumObservedPoints(0)
  , laserNumCorrespondences(0)
  , laserStage0Weights(0.0)
  , laserStageRWeights(0.0)
  , laserMeanSqError(0.0)
  , lastPointCloudRunTime(0.0)
  , pointCloudRunTime(0.0)
  , pointCloudNumObservedPoints(0)
  , pointCloudNumCorrespondences(0)
  , pointCloudStage0Weights(0.0)
  , pointCloudStageRWeights(0.0)
  , pointCloudMeanSqError(0.0)
  {
  }

  typedef double _timeStamp_type;
  double timeStamp;

  typedef float _x_type;
  float x;

  typedef float _y_type;
  float y;

  typedef float _angle_type;
  float angle;

  typedef float _angleUncertainty_type;
  float angleUncertainty;

  typedef float _locationUncertainty_type;
  float locationUncertainty;

  typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _map_type;
  std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  map;

  typedef double _lastLaserRunTime_type;
  double lastLaserRunTime;

  typedef double _laserRunTime_type;
  double laserRunTime;

  typedef int32_t _laserNumObservedPoints_type;
  int32_t laserNumObservedPoints;

  typedef int32_t _laserNumCorrespondences_type;
  int32_t laserNumCorrespondences;

  typedef float _laserStage0Weights_type;
  float laserStage0Weights;

  typedef float _laserStageRWeights_type;
  float laserStageRWeights;

  typedef float _laserMeanSqError_type;
  float laserMeanSqError;

  typedef double _lastPointCloudRunTime_type;
  double lastPointCloudRunTime;

  typedef double _pointCloudRunTime_type;
  double pointCloudRunTime;

  typedef int32_t _pointCloudNumObservedPoints_type;
  int32_t pointCloudNumObservedPoints;

  typedef int32_t _pointCloudNumCorrespondences_type;
  int32_t pointCloudNumCorrespondences;

  typedef float _pointCloudStage0Weights_type;
  float pointCloudStage0Weights;

  typedef float _pointCloudStageRWeights_type;
  float pointCloudStageRWeights;

  typedef float _pointCloudMeanSqError_type;
  float pointCloudMeanSqError;


  typedef boost::shared_ptr< ::vector_slam_msgs::CobotLocalizationMsg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::vector_slam_msgs::CobotLocalizationMsg_<ContainerAllocator>  const> ConstPtr;
}; // struct CobotLocalizationMsg
typedef  ::vector_slam_msgs::CobotLocalizationMsg_<std::allocator<void> > CobotLocalizationMsg;

typedef boost::shared_ptr< ::vector_slam_msgs::CobotLocalizationMsg> CobotLocalizationMsgPtr;
typedef boost::shared_ptr< ::vector_slam_msgs::CobotLocalizationMsg const> CobotLocalizationMsgConstPtr;


template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::vector_slam_msgs::CobotLocalizationMsg_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::vector_slam_msgs::CobotLocalizationMsg_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace vector_slam_msgs

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::vector_slam_msgs::CobotLocalizationMsg_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::vector_slam_msgs::CobotLocalizationMsg_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::vector_slam_msgs::CobotLocalizationMsg_<ContainerAllocator> > {
  static const char* value() 
  {
    return "88e4cd133e897255a68320aa8fedc7f7";
  }

  static const char* value(const  ::vector_slam_msgs::CobotLocalizationMsg_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x88e4cd133e897255ULL;
  static const uint64_t static_value2 = 0xa68320aa8fedc7f7ULL;
};

template<class ContainerAllocator>
struct DataType< ::vector_slam_msgs::CobotLocalizationMsg_<ContainerAllocator> > {
  static const char* value() 
  {
    return "vector_slam_msgs/CobotLocalizationMsg";
  }

  static const char* value(const  ::vector_slam_msgs::CobotLocalizationMsg_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::vector_slam_msgs::CobotLocalizationMsg_<ContainerAllocator> > {
  static const char* value() 
  {
    return "float64 timeStamp\n\
float32 x\n\
float32 y\n\
float32 angle\n\
float32 angleUncertainty\n\
float32 locationUncertainty\n\
string map\n\
\n\
float64 lastLaserRunTime\n\
float64 laserRunTime\n\
int32 laserNumObservedPoints\n\
int32 laserNumCorrespondences\n\
float32 laserStage0Weights\n\
float32 laserStageRWeights\n\
float32 laserMeanSqError\n\
\n\
float64 lastPointCloudRunTime\n\
float64 pointCloudRunTime\n\
int32 pointCloudNumObservedPoints\n\
int32 pointCloudNumCorrespondences\n\
float32 pointCloudStage0Weights\n\
float32 pointCloudStageRWeights\n\
float32 pointCloudMeanSqError\n\
\n\
\n\
";
  }

  static const char* value(const  ::vector_slam_msgs::CobotLocalizationMsg_<ContainerAllocator> &) { return value(); } 
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::vector_slam_msgs::CobotLocalizationMsg_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.timeStamp);
    stream.next(m.x);
    stream.next(m.y);
    stream.next(m.angle);
    stream.next(m.angleUncertainty);
    stream.next(m.locationUncertainty);
    stream.next(m.map);
    stream.next(m.lastLaserRunTime);
    stream.next(m.laserRunTime);
    stream.next(m.laserNumObservedPoints);
    stream.next(m.laserNumCorrespondences);
    stream.next(m.laserStage0Weights);
    stream.next(m.laserStageRWeights);
    stream.next(m.laserMeanSqError);
    stream.next(m.lastPointCloudRunTime);
    stream.next(m.pointCloudRunTime);
    stream.next(m.pointCloudNumObservedPoints);
    stream.next(m.pointCloudNumCorrespondences);
    stream.next(m.pointCloudStage0Weights);
    stream.next(m.pointCloudStageRWeights);
    stream.next(m.pointCloudMeanSqError);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct CobotLocalizationMsg_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::vector_slam_msgs::CobotLocalizationMsg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::vector_slam_msgs::CobotLocalizationMsg_<ContainerAllocator> & v) 
  {
    s << indent << "timeStamp: ";
    Printer<double>::stream(s, indent + "  ", v.timeStamp);
    s << indent << "x: ";
    Printer<float>::stream(s, indent + "  ", v.x);
    s << indent << "y: ";
    Printer<float>::stream(s, indent + "  ", v.y);
    s << indent << "angle: ";
    Printer<float>::stream(s, indent + "  ", v.angle);
    s << indent << "angleUncertainty: ";
    Printer<float>::stream(s, indent + "  ", v.angleUncertainty);
    s << indent << "locationUncertainty: ";
    Printer<float>::stream(s, indent + "  ", v.locationUncertainty);
    s << indent << "map: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.map);
    s << indent << "lastLaserRunTime: ";
    Printer<double>::stream(s, indent + "  ", v.lastLaserRunTime);
    s << indent << "laserRunTime: ";
    Printer<double>::stream(s, indent + "  ", v.laserRunTime);
    s << indent << "laserNumObservedPoints: ";
    Printer<int32_t>::stream(s, indent + "  ", v.laserNumObservedPoints);
    s << indent << "laserNumCorrespondences: ";
    Printer<int32_t>::stream(s, indent + "  ", v.laserNumCorrespondences);
    s << indent << "laserStage0Weights: ";
    Printer<float>::stream(s, indent + "  ", v.laserStage0Weights);
    s << indent << "laserStageRWeights: ";
    Printer<float>::stream(s, indent + "  ", v.laserStageRWeights);
    s << indent << "laserMeanSqError: ";
    Printer<float>::stream(s, indent + "  ", v.laserMeanSqError);
    s << indent << "lastPointCloudRunTime: ";
    Printer<double>::stream(s, indent + "  ", v.lastPointCloudRunTime);
    s << indent << "pointCloudRunTime: ";
    Printer<double>::stream(s, indent + "  ", v.pointCloudRunTime);
    s << indent << "pointCloudNumObservedPoints: ";
    Printer<int32_t>::stream(s, indent + "  ", v.pointCloudNumObservedPoints);
    s << indent << "pointCloudNumCorrespondences: ";
    Printer<int32_t>::stream(s, indent + "  ", v.pointCloudNumCorrespondences);
    s << indent << "pointCloudStage0Weights: ";
    Printer<float>::stream(s, indent + "  ", v.pointCloudStage0Weights);
    s << indent << "pointCloudStageRWeights: ";
    Printer<float>::stream(s, indent + "  ", v.pointCloudStageRWeights);
    s << indent << "pointCloudMeanSqError: ";
    Printer<float>::stream(s, indent + "  ", v.pointCloudMeanSqError);
  }
};


} // namespace message_operations
} // namespace ros

#endif // VECTOR_SLAM_MSGS_MESSAGE_COBOTLOCALIZATIONMSG_H

